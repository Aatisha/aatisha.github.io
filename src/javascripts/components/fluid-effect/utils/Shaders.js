/* eslint-disable no-tabs */

export const vertexShader = '#define GLSLIFY 1\nuniform vec2 center;\nuniform vec2 size;\nvarying vec2 vUv;\n\nvoid main(){\n    vUv = uv;\n    gl_Position = vec4(position.xy * size + center, 0.0, 1.0);\n}\n';

export const fragmentShader = '#define GLSLIFY 1\nuniform sampler2D grad;\nuniform float opacity;\nuniform float time;\nuniform float colorChange;\nvarying vec2 vUv;\n\nvoid main() {\n	vec2 circle = (vUv - 0.5) * 2.0;\n	float d = 1.0 - min(length(circle), 1.0);\n	d *= d;\n	//	d = step(0.5, d);\n	float c = (cos(time * colorChange) + 1.0) * 0.5;\n	vec3 col = texture2D(grad, vec2(c, 0.0)).rgb;\n	float a = d * opacity;\n	gl_FragColor = vec4(col, a);\n	//	gl_FragColor = vec4(col, 0.01);\n}\n';

export const velocityFragmentShader = '#define GLSLIFY 1\nuniform vec2 force;\nuniform vec2 center;\nuniform vec2 scale;\nvarying vec2 vUv;\n\nvoid main(){\n    vec2 circle = (vUv - 0.5) * 2.0;\n    float d = 1.0 - min(length(circle), 1.0);\n    d *= d;\n    gl_FragColor = vec4(force, 0.0, d);\n}\n';

export const faceVertexShader = '#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(){\n    vUv = vec2(0.5)+(position.xy)*0.5;\n    gl_Position = vec4(position, 1.0);\n}\n';

export const advectionShader = '#define GLSLIFY 1\nuniform sampler2D velocity;\nuniform vec2 size;\nuniform float delta;\n\nvarying vec2 vUv;\n\nvoid main() {\n	vec2 ratio = max(size.x, size.y) / size;\n	vec2 spot_new = vUv;\n	vec2 vel_old = texture2D(velocity, vUv).xy;\n	// back trace\n	vec2 spot_old = spot_new - vel_old * delta * ratio;\n	vec2 vel_new1 = texture2D(velocity, spot_old).xy;\n\n	// forward trace\n	vec2 spot_new2 = spot_old + vel_new1 * delta * ratio;\n\n	vec2 error = spot_new2 - spot_new;\n\n	vec2 spot_new3 = spot_new - error / 2.0;\n	vec2 vel_2 = texture2D(velocity, spot_new3).xy;\n\n	// back trace 2\n	vec2 spot_old2 = spot_new3 - vel_2 * delta * ratio;\n	vec2 newVel2 = texture2D(velocity, spot_old2).xy * 0.997;\n	gl_FragColor = vec4(newVel2, 0.0, 1.0);\n}\n';

export const divergenceShader = '#define GLSLIFY 1\nuniform sampler2D velocity;\nuniform float delta;\nuniform vec2 cellSize;\nvarying vec2 vUv;\n\nvoid main(){\n    float x0 = texture2D(velocity, vUv-vec2(cellSize.x, 0)).x;\n    float x1 = texture2D(velocity, vUv+vec2(cellSize.x, 0)).x;\n    float y0 = texture2D(velocity, vUv-vec2(0, cellSize.y)).y;\n    float y1 = texture2D(velocity, vUv+vec2(0, cellSize.y)).y;\n    float divergence = (x1-x0 + y1-y0) / 2.0;\n\n    gl_FragColor = vec4(divergence / delta);\n}\n';

export const dyeShader = '#define GLSLIFY 1\nuniform sampler2D dye;\nuniform sampler2D velocity;\nuniform vec2 size;\nuniform float delta;\nuniform float decay;\n\nvarying vec2 vUv;\n\nvoid main() {\n	vec2 ratio = max(size.x, size.y) / size;\n	vec2 spot_new = vUv;\n	vec2 vel_old = texture2D(velocity, vUv).xy;\n	// back trace\n	vec2 spot_old = spot_new - vel_old * delta * ratio;\n	vec2 vel_new1 = texture2D(velocity, spot_old).xy;\n\n	// forward trace\n	vec2 spot_new2 = spot_old + vel_new1 * delta * ratio;\n\n	vec2 error = spot_new2 - spot_new;\n\n	vec2 spot_new3 = spot_new - error / 2.0;\n	vec2 vel_2 = texture2D(velocity, spot_new3).xy;\n\n	// back trace 2\n	vec2 spot_old2 = spot_new3 - vel_2 * delta * ratio;\n\n	vec3 color = texture2D(dye, spot_old2).rgb * decay;\n	gl_FragColor = vec4(color, 1.0);\n}\n';

export const outputVertexShader = '#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main(){\n    vUv = vec2(0.5)+(position.xy)*0.5;\n\n    gl_Position = vec4(position, 1.0);\n}\n';

export const outputFragmentShader = "#define GLSLIFY 1\nuniform sampler2D diffuse;\nuniform float amount;\nuniform float smoothAmount;\nuniform float elapsed;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\nfloat sdCircle(vec2 p, float r) {\n	return length(p) - r;\n}\n\nfloat random(vec2 p) {\n	vec2 K1 = vec2(\n		23.14069263277926, // e^pi (Gelfond's constant)\n		2.665144142690225 // 2^sqrt(2) (Gelfond\u2013Schneider constant)\n	);\n	return fract(cos(dot(p, K1)) * 12345.6789);\n}\n\nvec3 black = vec3(0.0);\n\nvoid main() {\n	vec4 color = texture2D(diffuse, vUv);\n	vec2 uvRandom = vUv;\n	float aspect = resolution.y / resolution.x;\n	vec2 center = (vUv * 2.0 - 1.0) * vec2(1.0, resolution.y / resolution.x);\n\n	float d = sdCircle(center, elapsed);\n	float c = clamp(smoothstep(0.0, smoothAmount, d), 0.0, 1.0);\n\n	uvRandom.y *= random(vec2(uvRandom.y));\n	color.rgb += random(uvRandom) * 0.075;\n\n	gl_FragColor = vec4(mix(color.rgb, black, c), amount);\n}\n";

export const poissonFragmentShader = '#define GLSLIFY 1\nuniform sampler2D pressure;\nuniform sampler2D divergence;\nuniform vec2 cellSize;\nvarying vec2 vUv;\n\nvoid main(){    \n    // poisson equation\n    float p0 = texture2D(pressure, vUv+vec2(cellSize.x * 2.0,  0)).r;\n    float p1 = texture2D(pressure, vUv-vec2(cellSize.x * 2.0, 0)).r;\n    float p2 = texture2D(pressure, vUv+vec2(0, cellSize.y * 2.0 )).r;\n    float p3 = texture2D(pressure, vUv-vec2(0, cellSize.y * 2.0 )).r;\n    float div = texture2D(divergence, vUv).r;\n\n    float newP = (p0 + p1 + p2 + p3) / 4.0 - div;\n    gl_FragColor = vec4(newP);\n}\n';

export const pressureFragmentShader = '#define GLSLIFY 1\nuniform sampler2D pressure;\nuniform sampler2D velocity;\nuniform vec2 cellSize;\nuniform float delta;\nvarying vec2 vUv;\n\nvoid main(){\n    float step = 1.0;\n\n    float p0 = texture2D(pressure, vUv+vec2(cellSize.x * step, 0)).r;\n    float p1 = texture2D(pressure, vUv-vec2(cellSize.x * step, 0)).r;\n    float p2 = texture2D(pressure, vUv+vec2(0, cellSize.y * step)).r;\n    float p3 = texture2D(pressure, vUv-vec2(0, cellSize.y * step)).r;\n\n    vec2 v = texture2D(velocity, vUv).xy;\n    vec2 gradP = vec2(p0 - p1, p2 - p3) * 0.5;\n    v = v - gradP * delta;\n    gl_FragColor = vec4(v, 0.0, 1.0);\n}\n';

export const pointerVertexShader = '#define GLSLIFY 1\nuniform vec2 center;\nuniform vec2 size;\nvarying vec2 vUv;\n\nvoid main(){\n    vUv = uv;\n    gl_Position = vec4(position.xy * size + center, 0.0, 1.0);\n}\n';

export const labelVertexShader = '#define GLSLIFY 1\nuniform vec2 resolution;\nuniform float offset;\nuniform float width;\nuniform float time;\n\nvarying vec2 vUv;\nvarying vec2 vOffset;\nvarying float vAlpha;\n\n//https://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle) {\n	axis = normalize(axis);\n	float s = sin(angle);\n	float c = cos(angle);\n	float oc = 1.0 - c;\n\n	return mat4(\n		oc * axis.x * axis.x + c,\n		oc * axis.x * axis.y - axis.z * s,\n		oc * axis.z * axis.x + axis.y * s,\n		0.0,\n		oc * axis.x * axis.y + axis.z * s,\n		oc * axis.y * axis.y + c,\n		oc * axis.y * axis.z - axis.x * s,\n		0.0,\n		oc * axis.z * axis.x - axis.y * s,\n		oc * axis.y * axis.z + axis.x * s,\n		oc * axis.z * axis.z + c,\n		0.0,\n		0.0,\n		0.0,\n		0.0,\n		1.0\n	);\n}\n\nfloat map(float value, float inMin, float inMax, float outMin, float outMax) {\n	return outMin + (outMax - outMin) * (value - inMin) / (inMax - inMin);\n}\n\nvec3 axis = vec3(1.0, 0.0, 0.0);\n\nvoid main() {\n	vUv = uv;\n	vec4 pos = vec4(position, 1.0);\n\n	vec4 transformed = vec4(position, 1.0);\n\n	float leftOffset = pos.x / width;\n	float o = clamp(abs(leftOffset + offset * 5.0) - 1.0, 0.0, 2.0);\n	float rotation = smoothstep(0.0, 2.0, o);\n	float s = sign(offset);\n	float angle = radians(rotation * 120.0 * s);\n	mat4 matrix = rotationMatrix(axis, angle);\n	vAlpha = 1.0 - smoothstep(0.25, 1.0, rotation * 1.25);\n\n	transformed.x += rotation * 0.01 * s;\n	transformed.z +=\n		(cos(position.x * 12.0 + time * 0.004) * 0.02 + sin(position.y * 6.0 + time * 0.003) * 0.01) * rotation;\n	vec4 rotatedPosition = matrix * transformed;\n\n	gl_Position = projectionMatrix * modelViewMatrix * rotatedPosition;\n}\n';

export const labelFragmentShader = '#define GLSLIFY 1\nuniform vec2 resolution;\nuniform sampler2D sdf;\nuniform sampler2D map;\nuniform vec3 color;\nuniform float offset;\nuniform float opacity;\nvarying vec2 vUv;\nvarying float vAlpha;\n\nfloat median(float r, float g, float b) {\n	return max(min(r, g), min(max(r, g), b));\n}\n\nvoid main() {\n	vec2 st = gl_FragCoord.xy / resolution;\n	vec3 diffuse = texture2D(map, st).rgb;\n	float a1 = max(diffuse.r, diffuse.g);\n	float a2 = 1.0 - max(a1, diffuse.b);\n\n	vec3 c = mix(color, diffuse, a2);\n	vec3 s = texture2D(sdf, vUv).rgb;\n	float sigDist = median(s.r, s.g, s.b) - 0.5;\n	float alpha = clamp(sigDist / (abs(dFdx(sigDist)) + abs(dFdy(sigDist))) + 0.5, 0.0, 1.0);\n\n	gl_FragColor = vec4(color, alpha * a2 * opacity * vAlpha);\n}\n';

export const blurFragmentShader = '#define GLSLIFY 1\nuniform sampler2D map;\nuniform float alpha;\nuniform vec2 delta;\nuniform vec2 resolution;\n\nfloat random(vec3 scale, float seed) {\n	return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n}\n\nvoid main() {\n	vec2 st = gl_FragCoord.xy / resolution;\n\n	vec4 color = vec4(0.0);\n	float total = 0.0;\n\n	float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n	for (float t = -10.0; t <= 10.0; t++) {\n		float percent = (t + offset - 0.5) / 10.0;\n		float weight = 1.0 - abs(percent);\n		vec4 sampleColor = texture2D(map, st + delta * percent);\n\n		color += sampleColor * weight;\n		total += weight;\n	}\n\n	gl_FragColor = color / total;\n}\n';

export const blurVertexShader = '#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}';

export const labelVertexShader2 = '#define GLSLIFY 1\nattribute vec3 translate;\nattribute float opacity;\n\nuniform float size;\nvarying float vOpacity;\nvarying vec2 vUv;\n\nvoid main() {\n	vUv = uv;\n	vOpacity = opacity;\n	vec3 transformed = position + translate;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);\n}\n';

export const lineFragmentShader = '#define GLSLIFY 1\nuniform vec3 color;\nuniform vec2 resolution;\nuniform sampler2D map;\nuniform float opacity;\nvarying float vOpacity;\n\nvoid main() {\n	vec2 st = gl_FragCoord.xy / resolution;\n	vec3 diffuse = texture2D(map, st).rgb;\n	float a1 = max(diffuse.r, diffuse.g);\n	float a2 = 1.0 - max(a1, diffuse.b);\n	gl_FragColor = vec4(color, vOpacity * opacity * a2);\n}\n';

export const lineVertexShader = '#define GLSLIFY 1\nattribute vec3 translate;\nattribute vec3 scale;\nattribute float opacity;\nvarying float vOpacity;\n\nvoid main() {\n	vOpacity = opacity;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position + translate, 1.0);\n}\n';

export const gridVertexShader = '#define GLSLIFY 1\nattribute vec3 translate;\nattribute float opacity;\nattribute float rotation;\n\nuniform float size;\nvarying float vRotation;\nvarying float vOpacity;\nvarying vec2 vUv;\n\nvoid main() {\n	vRotation = rotation;\n	vOpacity = opacity;\n	vec3 transformed = position + translate;\n	gl_PointSize = size;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);\n}\n';

export const gridFragmentShader = '#define GLSLIFY 1\nuniform vec2 uvOffset;\nuniform vec3 color;\nuniform vec2 resolution;\nuniform sampler2D pointMap;\nuniform sampler2D map;\nuniform float opacity;\n\nvarying float vRotation;\nvarying float vOpacity;\n\nvec2 rotateUV(vec2 uv, float rotation) {\n	float mid = 0.5;\n	return vec2(\n		cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n		cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n	);\n}\n\nvec2 uvScale = vec2(0.25);\n\nvoid main() {\n	vec2 st = gl_FragCoord.xy / resolution;\n	vec3 diffuse = texture2D(map, st).rgb;\n	float a1 = max(diffuse.r, diffuse.g);\n	float a2 = 1.0 - max(a1, diffuse.b);\n	vec2 uv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);\n	vec2 rotatedUv = rotateUV(uv, vRotation) * uvScale + uvOffset;\n	float alpha = texture2D(pointMap, rotatedUv).r;\n	gl_FragColor = vec4(color, alpha * vOpacity * opacity * a2);\n}\n';

export const msdfVertexShader = '#define GLSLIFY 1\nattribute vec3 translate;\nattribute float opacity;\n\nvarying vec2 vUv;\nvarying float vOpacity;\n\nvoid main() {\n    vUv = uv;\n    vOpacity = opacity;\n    vec3 transformed = position + translate;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);\n}';

export const msdfFragmentShader = '#define GLSLIFY 1\nuniform float opacity;\nuniform vec3 color;\nuniform vec2 resolution;\nuniform sampler2D sdf;\nuniform sampler2D map;\n\nvarying vec2 vUv;\nvarying float vOpacity;\n\nfloat median(float r, float g, float b) {\n	return max(min(r, g), min(max(r, g), b));\n}\n\nvoid main() {\n	vec2 st = gl_FragCoord.xy / resolution;\n	vec3 diffuse = texture2D(map, st).rgb;\n	float a1 = max(diffuse.r, diffuse.g);\n	float a2 = 1.0 - max(a1, diffuse.b);\n	vec3 s = texture2D(sdf, vUv).rgb;\n	float sigDist = median(s.r, s.g, s.b) - 0.5;\n	float alpha = clamp(sigDist / (abs(dFdx(sigDist)) + abs(dFdy(sigDist))) + 0.5, 0.0, 1.0);\n\n	gl_FragColor = vec4(color, alpha * vOpacity * opacity * a2);\n}\n';

export const msdfIntroVertexShader = '#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n';

export const msdfIntroFragmentShader = '#define GLSLIFY 1\nuniform vec3 color;\nuniform float useDiffuse;\nuniform float opacity;\nuniform float mapOpacity;\nuniform vec2 resolution;\nuniform sampler2D sdf;\nuniform sampler2D map;\n\nvarying vec2 vUv;\n\nfloat median(float r, float g, float b) {\n	return max(min(r, g), min(max(r, g), b));\n}\n\nvoid main() {\n	vec2 st = gl_FragCoord.xy / resolution;\n	vec3 diffuse = texture2D(map, st).rgb;\n\n	float a1 = max(diffuse.r, diffuse.g);\n	float a2 = clamp(1.0 - max(a1, diffuse.b) * mapOpacity + useDiffuse, 0.0, 1.0);\n	vec3 s = texture2D(sdf, vUv).rgb;\n	float sigDist = median(s.r, s.g, s.b) - 0.5;\n	float alpha = clamp(sigDist / (abs(dFdx(sigDist)) + abs(dFdy(sigDist))) + 0.5, 0.0, 1.0);\n\n	gl_FragColor = vec4(mix(color, diffuse, useDiffuse), alpha * opacity * a2);\n}\n';

export const panelVertexShader = '#define GLSLIFY 1\nvoid main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n';

export const panelFragmentShader = "#define GLSLIFY 1\nuniform vec2 resolution;\nuniform sampler2D map;\nuniform vec3 color;\nuniform float opacity;\nuniform float noise;\n\nfloat random(vec2 p) {\n	vec2 K1 = vec2(\n		23.14069263277926, // e^pi (Gelfond's constant)\n		2.665144142690225 // 2^sqrt(2) (Gelfond\u2013Schneider constant)\n	);\n	return fract(cos(dot(p, K1)) * 12345.6789);\n}\n\nvoid main() {\n	vec2 st = gl_FragCoord.xy / resolution;\n	vec3 diffuse = texture2D(map, st).rgb;\n\n	st.y *= random(vec2(st.y, 0.1));\n	diffuse.rgb += random(st) * noise;\n\n	gl_FragColor = vec4(color + diffuse, opacity);\n}\n";
